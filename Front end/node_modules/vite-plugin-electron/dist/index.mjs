import { mergeConfig, build as build$1 } from "vite";
import { builtinModules } from "node:module";
function resolveViteConfig(options) {
  const defaultConfig = {
    // ðŸš§ Avoid recursive build caused by load config file
    configFile: false,
    publicDir: false,
    build: {
      // @ts-ignore
      lib: options.entry && {
        entry: options.entry,
        // At present, Electron(20) can only support CommonJs
        formats: ["cjs"],
        fileName: () => "[name].js"
      },
      outDir: "dist-electron",
      // Avoid multiple entries affecting each other
      emptyOutDir: false
    },
    resolve: {
      // #136
      // Some libs like `axios` must disable the `browserField`.
      // @axios https://github.com/axios/axios/blob/v1.3.5/package.json#L129
      // @vite https://github.com/vitejs/vite/blob/v4.2.1/packages/vite/src/node/plugins/resolve.ts#L294
      browserField: false,
      // #98
      // Since we're building for electron (which uses Node.js), we don't want to use the "browser" field in the packages.
      // It corrupts bundling packages like `ws` and `isomorphic-ws`, for example.
      mainFields: ["module", "jsnext:main", "jsnext"]
    }
  };
  return mergeConfig(defaultConfig, (options == null ? void 0 : options.vite) || {});
}
function withExternalBuiltins(config) {
  var _a;
  const builtins = builtinModules.filter((e) => !e.startsWith("_"));
  builtins.push("electron", ...builtins.map((m) => `node:${m}`));
  config.build ?? (config.build = {});
  (_a = config.build).rollupOptions ?? (_a.rollupOptions = {});
  let external = config.build.rollupOptions.external;
  if (Array.isArray(external) || typeof external === "string" || external instanceof RegExp) {
    external = builtins.concat(external);
  } else if (typeof external === "function") {
    const original = external;
    external = function(source, importer, isResolved) {
      if (builtins.includes(source)) {
        return true;
      }
      return original(source, importer, isResolved);
    };
  } else {
    external = builtins;
  }
  config.build.rollupOptions.external = external;
  return config;
}
function resolveHostname(hostname) {
  const loopbackHosts = /* @__PURE__ */ new Set([
    "localhost",
    "127.0.0.1",
    "::1",
    "0000:0000:0000:0000:0000:0000:0000:0001"
  ]);
  const wildcardHosts = /* @__PURE__ */ new Set([
    "0.0.0.0",
    "::",
    "0000:0000:0000:0000:0000:0000:0000:0000"
  ]);
  return loopbackHosts.has(hostname) || wildcardHosts.has(hostname) ? "localhost" : hostname;
}
function resolveServerUrl(server) {
  const addressInfo = server.httpServer.address();
  const isAddressInfo = (x) => x == null ? void 0 : x.address;
  if (isAddressInfo(addressInfo)) {
    const { address, port } = addressInfo;
    const hostname = resolveHostname(address);
    const options = server.config.server;
    const protocol = options.https ? "https" : "http";
    const devBase = server.config.base;
    const path = typeof options.open === "string" ? options.open : devBase;
    const url = path.startsWith("http") ? path : `${protocol}://${hostname}:${port}${path}`;
    return url;
  }
}
function build(options) {
  return build$1(withExternalBuiltins(resolveViteConfig(options)));
}
function electron(options) {
  const optionsArray = Array.isArray(options) ? options : [options];
  let mode;
  return [
    {
      name: "vite-plugin-electron",
      apply: "serve",
      configureServer(server) {
        var _a;
        (_a = server.httpServer) == null ? void 0 : _a.once("listening", () => {
          var _a2, _b, _c, _d, _e;
          Object.assign(process.env, {
            VITE_DEV_SERVER_URL: resolveServerUrl(server)
          });
          for (const options2 of optionsArray) {
            options2.vite ?? (options2.vite = {});
            (_a2 = options2.vite).mode ?? (_a2.mode = server.config.mode);
            (_b = options2.vite).build ?? (_b.build = {});
            (_c = options2.vite.build).watch ?? (_c.watch = {});
            (_d = options2.vite.build).minify ?? (_d.minify = false);
            (_e = options2.vite).plugins ?? (_e.plugins = []);
            options2.vite.plugins.push(
              {
                name: ":startup",
                closeBundle() {
                  if (options2.onstart) {
                    options2.onstart.call(this, {
                      startup,
                      reload() {
                        server.ws.send({ type: "full-reload" });
                      }
                    });
                  } else {
                    startup();
                  }
                }
              }
            );
            build(options2);
          }
        });
      }
    },
    {
      name: "vite-plugin-electron",
      apply: "build",
      config(config, env) {
        config.base ?? (config.base = "./");
        mode = env.mode;
      },
      async closeBundle() {
        var _a;
        for (const options2 of optionsArray) {
          options2.vite ?? (options2.vite = {});
          (_a = options2.vite).mode ?? (_a.mode = mode);
          await build(options2);
        }
      }
    }
  ];
}
async function startup(argv = [".", "--no-sandbox"]) {
  const { spawn } = await import("node:child_process");
  const electron2 = await import("electron");
  const electronPath = electron2.default ?? electron2;
  startup.exit();
  process.electronApp = spawn(electronPath, argv, { stdio: "inherit" });
  process.electronApp.once("exit", process.exit);
  if (!startup.hookProcessExit) {
    startup.hookProcessExit = true;
    process.once("exit", startup.exit);
  }
}
startup.hookProcessExit = false;
startup.exit = () => {
  if (process.electronApp) {
    process.electronApp.removeAllListeners();
    process.electronApp.kill();
  }
};
export {
  build,
  electron as default,
  resolveViteConfig,
  startup,
  withExternalBuiltins
};
